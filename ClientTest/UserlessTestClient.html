<!DOCTYPE html>
<html>
<head>
    <title>Userless Test Client</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Ensure use of most common Unicode characters -->
    <meta charset="utf-8">

		<!-- https://picturepan2.github.io/spectre/index.html -->

    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <!-- Considered an "experimental" feature -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <!-- Spectre.css icons are used -->

    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css"> 
</head>

<body>
	<div class="container">
		<div class="accordion">
		  <input type="checkbox" id="accordion-1" name="accordion-checkbox" hidden>
		  <label class="accordion-header" for="accordion-1">
		    <i class="icon icon-arrow-right mr-1"></i>
		    Console
		  </label>
		  <div class="accordion-body">
	 			<pre id="console" style="font-size: 10px"> </pre>  
		  </div>
		</div>

	  <div class="columns">
	    <div class="column col-sm">
	      <div class="card">
	        <h4>Register</h4>
	        <div class="card-body">
	          <form id="register" onsubmit="return false">
							<div class="form-group">
							  <label class="form-switch" >
							    <input type="checkbox" name="usePlatformAuthenticator">
							    <i class="form-icon"></i> use platform authenticator
							  </label>
							  <label class="form-switch" >
							    <input type="checkbox" name="requireResidentKey" checked="">
							    <i class="form-icon"></i> require resident key
							  </label>
							  <label class="form-switch" >
							    <input type="checkbox" name="requireDirectAttestation">
							    <i class="form-icon"></i> require attestation (direct)
							  </label>
							</div>
	              <input type="text" name="username" placeholder="Username" style="font-size: 14px"><br>
	              <input type="text" name="displayName" placeholder="DisplayName" style="font-size: 14px"><br>
	              <button class="btn btn-primary btn-sm" action="submit">Register</button>
		          </form>
						<br>
						<div class="text-break">
			        <b style="font-size: 12px">2. App to Client</b>
 			        <pre id="reg2" style="font-size: 10px"> </pre>  
			        <b style="font-size: 12px">3. Client to App</b>
			        <pre id="reg3" style="font-size: 10px"> </pre>
			        <pre id="reg3b" style="font-size: 10px"> </pre>
						</div>
					</div><!-- .card-body --> 
	      </div><!-- .card -->
			</div><!-- .column col-4 -->

	    <div class="column col-sm">
				<div class="card">
				  <h4>Authenticate</h4>
			    <div class="card-body">
		        <form id="login" onsubmit="return false">
							<div class="form-group">
							  <label class="form-switch" >
							    <input type="checkbox" name="allowCredentialsSelection">
							    <i class="form-icon"></i> allowCredentials (use last credential created in this client)
							  </label>
							</div>
 							<label class="form-label" for="output-credid">cedentialID</label>
							<div class="col-9 col-sm-12">
						  	<input class="form-input" type="text" name="credentialID" id="output-credid" style="font-size: 12px" disabled>
							</div>
	            <button class="btn btn-primary btn-sm" action="submit">Authenticate</button>
						</form>
						<br>
						<div class="text-break">
					    <b style="font-size: 12px">2. App to Client</b>
							<pre id="aut2" style="font-size: 10px"> </pre>   		
					    <b style="font-size: 12px">3. Client to App</b>
					    <pre id="aut3" style="font-size: 10px"> </pre>   				   				
						</div>
					</div><!-- .card-body -->			
				</div><!-- .card -->
			</div><!-- .column col-4 -->
					
		</div><!-- .columns -->  
	</div><!-- .container -->  

<!-- JS SECTION -->

    <script>

				let logtext = '';
				var log = (text, obj) => {
					if(obj) {
						logtext += (text +  "\n" + sf(obj) + "\n");
						console.log(text, obj);
					}
					else {
						logtext += (text + "\n");
						console.log(text);
					}
					document.getElementById("console").innerText = 	logtext;
				}

	      log('check for WebAuthn APIs ...');

				// webauthn API available?

    		if (!window.PublicKeyCredential) {
        	log('WebAuthn APIs are not available on this user agent!');
					alert('WebAuthn APIs are not available on this user agent!');
				}

				document.getElementById('register').setAttribute( "autocomplete", "off" ); 
				document.getElementById('login').setAttribute( "autocomplete", "off" );

				function markPlatformAuthenticatorUnavailable() {
					log('PlatformAuthenticator Unavailable');
					document.getElementById('register').usePlatformAuthenticator.disabled = true;
				}

	      log('check for platform authenticator....');

			  // Update UI to reflect availability of platform authenticator

			  if (window.PublicKeyCredential && typeof window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable !== "function") {
			    markPlatformAuthenticatorUnavailable();
			  } else if (window.PublicKeyCredential && typeof window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable === "function") {
			      window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable().then(available => {
			          if (!available) {
			              markPlatformAuthenticatorUnavailable();
			          }
			      }).catch(e=>{
			          markPlatformAuthenticatorUnavailable();
			      });
			  }	
	
				var showCredID = (ci) => {
					document.getElementById('login').credentialID.value = ci;
				}
				showCredID(localStorage.getItem("credentialId"));

        document.getElementById('register').addEventListener('submit', function(event) {
          event.preventDefault();

          var challenge = generateRandomBuffer();

					// using a hard coded userID for testing
          var userID = 'Kosv9fPtkDoh4Oz7Yq/pVgWHS8HhdlCto5cR0aBoVMw='
          var id = Uint8Array.from(window.atob(userID), c=>c.charCodeAt(0))

					var attachment = 'cross-platform';
					if(this.usePlatformAuthenticator.checked) {
						attachment = 'platform';
					}

					var attestation = 'none'; // not interested in authenticator attestation.
				  if (this.requireDirectAttestation.checked) {
						attestation = 'direct'; 
						// indicates that the Relying Party wants to receive the 
						// attestation statement as generated by the authenticator.
				  }
					// var attestation = 'indirect'; // if you want the client to anonymise your attestation, using for example Attestation CA
					// prefers an attestation conveyance yielding verifiable attestation statements, 
					// but allows the client to decide how to obtain such attestation statements.
					// client MAY replace the authenticator-generated attestation statements with 
					// attestation statements generated by an Anonymization CA,

					var residentkey = false;
				  if (this.requireResidentKey.checked) {
						residentkey = true; 
				  }

					// https://w3c.github.io/webauthn/#op-make-cred
		      var publicKey = {
            'challenge': challenge,

            'rp': {
                'name': 'Example Inc.'
            },

            'user': {
                'id': id, // It is RECOMMENDED to let the user handle be 64 random bytes, 
													// and store this value in the user's account.
                'name': this.username.value, // 'alice@example.com',
                'displayName': this.displayName.value // 'Alice im Wunderland'
            },
							
						'authenticatorSelection': {
  	          //Select authenticators that support username-less flows
							'requireResidentKey': residentkey, // seems to have no influence with yubikey, alow credentials shows difference for userHandle

            	//Select authenticators that have a second factor (e.g. PIN, Bio)
//            	userVerification: "required", //"preferred", "discouraged"

    	        //Selects between bound or detachable authenticators
	            authenticatorAttachment: attachment
						},

						'attestation': attestation,

            'pubKeyCredParams': [ // desired properties of the credential to be created, 
						// sequence ordered from most preferred to least preferred.
                { 'type': 'public-key', 'alg': -7  } //e.g. -7 for "ES256" and 
								,{ 'type': 'public-key', 'alg': -257 } // -257 for "RS256". 
            ],
		        //Since Edge shows UI, it is better to select larger timeout values
		        timeout: 50000
          }

					let a = document.getElementById("reg2");

				  document.getElementById("reg2").innerText = "navigator.credentials.create({publicKey:\n" + sf(publicKey) + "}";

					log('call navigator.credentials.create ...');

          return navigator.credentials.create({ 'publicKey': publicKey })
					// client adds for athenticator: hash (client data hash), requireUserPresence (inverse of requireUserVerification) 
          .then((rawAttestation) => {

	          log('RECEIVED AN ATTESTATION!');

						let clientData = parseClientDataJSON(rawAttestation.response.clientDataJSON);
          	log('ClientData: ', clientData);
						
						// Array attestationObject.authData: [RP ID hash | flags | counter | AAGUID | CredID | CredPubKey | Extensions]
          	let attestationObject = CBOR.decode(rawAttestation.response.attestationObject);
						/*
								attestationObject: {
									attStmt: Object, 
									authData: Array, 
									fmt: "packed" // "none", "packed", "tpm", "android-key","android-safetynet", "fido-u2f"
								}
						*/
	
		        let authData = parseAuthData(attestationObject.authData); // authData is an Array

	          log('AuthData: ', authData);
	          log('fmt: ', attestationObject.fmt);

						document.getElementById("reg3").innerText = 
								"rawAttestation:\n" + sf(publicKeyCredentialToJSON(rawAttestation)) + "\n" +
								"attestationObject:" + sf(attestationObject) + "\n" +
								"authData: " + attestationObject.authData.length + " bytes\n" + sf(authData) + "\n" 
						// "reg3" does not display whole text so use 2 elements instead
						document.getElementById("reg3b").innerText = 
								"UserPublicKey:" + sf(coseToJwk(authData.COSEPublicKey.buffer)) + "\n" +
								"clientData:\n" + sf(clientData);

//						let ci = base64url.encode(authData.credID);
						let ci = base64encode(authData.credID);
		        localStorage.setItem("credentialId", ci);
						showCredID(ci);

						alert('Received an Attestation of format: ' + attestationObject.fmt + ',\n saved credentialID:\n' + ci);
					})
          .catch((error) => {
              alert('fail to create credential! ' + error)
              log('fail to create credential!', error)
          })
  			})

        document.getElementById('login').addEventListener('submit', function(event) {
          event.preventDefault();

					var allowCredentials = [];
				  if (this.allowCredentialsSelection.checked) {
				      var credentialId = localStorage.getItem("credentialId");

							showCredID(credentialId);
				      if (!credentialId)
				          return Promise.reject("Please create a credential first");
				      
							allowCredentials = [{
          		  type: "public-key",
	       			  id: Uint8Array.from(atob(credentialId), c=>c.charCodeAt(0)).buffer
// 								id: stringToArrayBuffer(base64url.decode(credentialId))
        			}];
							// function stringToArrayBuffer(str){ return Uint8Array.from(str, c => c.charCodeAt(0)).buffer; }
							// atob() function decodes a string of data which has been encoded using base-64 encoding.

				  }

          var challenge = generateRandomBuffer();

					var publicKey = { //  contains only the challenge 
						// authenticatorSelection.requireResidentKey is true, so there is no need to pass a credential

		        // specifies which credential IDs are allowed to authenticate the user
		        allowCredentials: allowCredentials,
//						credentialMgmtPreview: true, // FIDO_2_1_PR

		        //an opaque challenge that the authenticator signs over
		        challenge: challenge,

		        //Since Edge shows UI, it is better to select larger timeout values
		        timeout: 50000
					}

					log('call navigator.credentials.get ...');
					log('publicKey: ', publicKey);

					document.getElementById("aut2").innerText = "navigator.credentials.get({publicKey:\n" + sf(publicKey)+ "}";

					
					return navigator.credentials.get({ 'publicKey': publicKey })
					// client adds for athenticator: rpId, hash(cient data hash), requireUserPresence
          .then((rawAssertion) => {

	          log('RECEIVED AN ASSERTION!');

						let clientData = parseClientDataJSON(rawAssertion.response.clientDataJSON);
          	log('ClientData: ', clientData);

						document.getElementById("aut3").innerText = "rawAssertion:\n" + 
							sf(publicKeyCredentialToJSON(rawAssertion)) + "\n" +
							sf(rawAssertion.response);

						// ArrayBuffer rawAssertion.response.authenticatorData: [RP ID hash | flags | counter | Attested CredData | Extensions]
						// [object AuthenticatorAssertionResponse]: {authenticatorData: ArrayBuffer, clientDataJSON: ArrayBuffer, signature: ArrayBuffer, userHandle: ArrayBuffer}

						let authDataBuffer = arrayBufferToUint8Array(rawAssertion.response.authenticatorData)
						let authData = parseAuthData(authDataBuffer);

	          log('authData: ', authData);
	          log('userHandle:', base64encode(rawAssertion.response.userHandle));
	          log('signature: ', base64encode(rawAssertion.response.signature));

						document.getElementById("aut3").innerText = 
								"rawAssertion:\n" + sf(publicKeyCredentialToJSON(rawAssertion)) + "\n" +
								"authenticatorData: " + authDataBuffer.length + " bytes\n" + sf(authData) + "\n" +
								"userHandle:" + sf(base64url.encode(rawAssertion.response.userHandle))  + "\n" +
								"signature:" + sf(base64url.encode(rawAssertion.response.signature)) + "\n" +
								"clientData:\n" + sf(clientData);

	/*
		        var assertion = {
		            id: base64encode(rawAssertion.rawId),
		            clientData: parseClientDataJSON(rawAssertion.response.clientDataJSON),
		            userHandle: base64encode(rawAssertion.response.userHandle),
		            signature: base64encode(rawAssertion.response.signature),
		            authenticatorData: base64encode(rawAssertion.response.authenticatorData)
		        }
					  document.getElementById("aut4").innerText = "authenticatorData:\n" + sf(authData);
*/
						alert('Received an assertion with userHandle:\n' + base64url.encode(rawAssertion.response.userHandle))
          })
          .catch((error) => {
              alert('fail get credential! ' + error)
              log('fail to get credential', error)
          })
    		})


    </script>
    <script src="../lib/base64url-arraybuffer.js"></script>
    <script src="../lib/cbor.js"></script>
    <script src="../lib/helpers.js"></script>
</body>
</html>