<!DOCTYPE html>
<html>
<head>
    <title>Userless Test Client</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Ensure use of most common Unicode characters -->
    <meta charset="utf-8">

		<!-- https://picturepan2.github.io/spectre/index.html -->

    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <!-- Considered an "experimental" feature -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <!-- Spectre.css icons are used -->

    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css"> 
</head>

<body>
	<div class="container">
		<div class="accordion">
		  <input type="checkbox" id="accordion-1" name="accordion-checkbox" hidden>
		  <label class="accordion-header" for="accordion-1">
		    <i class="icon icon-arrow-right mr-1"></i>
		    Console
		  </label>
		  <div class="accordion-body">
	 			<pre id="console" style="font-size: 10px"> </pre>  
		  </div>
		</div>

	  <div class="columns">
	    <div class="column col-sm">
	      <div class="card">
	        <h4>Register</h4>
	        <div class="card-body">
	          <form id="register" onsubmit="return false">
							<div class="form-group">
							  <label class="form-switch" >
							    <input type="checkbox" name="usePlatformAuthenticator">
							    <i class="form-icon"></i> use platform authenticator
							  </label>
							  <label class="form-switch" >
							    <input type="checkbox" name="requireResidentKey" checked="">
							    <i class="form-icon"></i> require resident key
							  </label>
							  <label class="form-switch" >
							    <input type="checkbox" name="requireDirectAttestation">
							    <i class="form-icon"></i> require attestation (direct)
							  </label>
							</div>
	              <input type="text" name="username" placeholder="Username" style="font-size: 14px"><br>
	              <input type="text" name="displayName" placeholder="DisplayName" style="font-size: 14px"><br>
	              <button class="btn btn-primary btn-sm" action="submit">Register</button>
		          </form>
						<br>
						<div class="text-break">
			        <b style="font-size: 12px">2. App to Client</b>
			   			<pre id="reg2" style="font-size: 10px"> </pre>   
			        <b style="font-size: 12px">3. Client to App</b>
			        <pre id="reg3" style="font-size: 10px"> </pre>   
						</div>
					</div><!-- .card-body --> 
	      </div><!-- .card -->
			</div><!-- .column col-4 -->

	    <div class="column col-sm">
				<div class="card">
				  <h4>Authenticate</h4>
			    <div class="card-body">
		        <form id="login" onsubmit="return false">
							<div class="form-group">
							  <label class="form-switch" >
							    <input type="checkbox" name="allowCredentialsSelection">
							    <i class="form-icon"></i> allowCredentials (use last credential created in this client)
							  </label>
							</div>
 							<label class="form-label" for="output-credid">cedentialID</label>
							<div class="col-9 col-sm-12">
						  	<input class="form-input" type="text" name="credentialID" id="output-credid" style="font-size: 12px" disabled>
							</div>
	            <button class="btn btn-primary btn-sm" action="submit">Authenticate</button>
						</form>
						<br>
						<br>
						<br>
						<div class="text-break">
					    <b style="font-size: 12px">2. App to Client</b>
							<pre id="aut2" style="font-size: 10px"> </pre>   		
					    <b style="font-size: 12px">3. Client to App</b>
					    <pre id="aut3" style="font-size: 10px"> </pre>   				
						</div>
					</div><!-- .card-body -->			
				</div><!-- .card -->
			</div><!-- .column col-4 -->
					
		</div><!-- .columns -->  
	</div><!-- .container -->  

<!-- JS SECTION -->

    <script>

				let logtext = '';
				var log = (text, obj) => {
					if(obj) {
						logtext += (text +  "\n" + sf(obj) + "\n");
						console.log(text, obj);
					}
					else {
						logtext += (text + "\n");
						console.log(text);
					}

					document.getElementById("console").innerText = 	logtext;
				}

    		if (!PublicKeyCredential) {
        	log('WebAuthn APIs are not available on this user agent!');
					alert('WebAuthn APIs are not available on this user agent!');
				}

				document.getElementById('register').setAttribute( "autocomplete", "off" ); 
				document.getElementById('login').setAttribute( "autocomplete", "off" );

				function markPlatformAuthenticatorUnavailable() {
					document.getElementById('register').usePlatformAuthenticator.disabled = true;
					log("PlatformAuthenticator Unavailable");
				}

			  //Update UI to reflect availability of platform authenticator
			  if (PublicKeyCredential && typeof PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable !== "function") {
			      markPlatformAuthenticatorUnavailable();
			  } else if (PublicKeyCredential && typeof PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable === "function") {
			      PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable().then(available => {
			          if (!available) {
			              markPlatformAuthenticatorUnavailable();
			          }
			      }).catch(e=>{
			          markPlatformAuthenticatorUnavailable();
			      });
			  }	
						
				var showCredID = (ci) => {
					document.getElementById('login').credentialID.value = ci;
				}

				showCredID(localStorage.getItem("credentialId"));

        document.getElementById('register').addEventListener('submit', function(event) {
          event.preventDefault();

          var challenge = new Uint8Array(32);
          window.crypto.getRandomValues(challenge);

          var userID = 'Kosv9fPtkDoh4Oz7Yq/pVgWHS8HhdlCto5cR0aBoVMw='
          var id = Uint8Array.from(window.atob(userID), c=>c.charCodeAt(0))

					var attachment = "cross-platform"
					if(this.usePlatformAuthenticator.checked) {
						attachment = "platform";
					}

					var attestation = 'none'; // not interested in authenticator attestation.
				  if (this.requireDirectAttestation.checked) {
						attestation = 'direct'; 
						// indicates that the Relying Party wants to receive the 
						// attestation statement as generated by the authenticator.
				  }
					// var attestation = 'indirect'; // if you want the client to anonymise your attestation, using for example Attestation CA
					// prefers an attestation conveyance yielding verifiable attestation statements, 
					// but allows the client to decide how to obtain such attestation statements.
					// client MAY replace the authenticator-generated attestation statements with 
					// attestation statements generated by an Anonymization CA,

					var residentkey = 'false';
				  if (this.requireResidentKey.checked) {
						residentkey = 'true'; 
				  }

		      var publicKey = {
            'challenge': challenge,

            'rp': {
                'name': 'Example Inc.'
            },

            'user': {
                'id': id, // It is RECOMMENDED to let the user handle be 64 random bytes, 
													// and store this value in the user's account.
                'name': this.username.value, // 'alice@example.com',
                'displayName': this.displayName.value // 'Alice im Wunderland'
            },
							
						'authenticatorSelection': {
  	          //Select authenticators that support username-less flows
							'requireResidentKey': residentkey, // seems to have no influence with yubikey, alow credentials shows difference für userHandle

            	//Select authenticators that have a second factor (e.g. PIN, Bio)
//            	userVerification: "required",

    	        //Selects between bound or detachable authenticators
	            authenticatorAttachment: attachment
						},

						'attestation': attestation,

            'pubKeyCredParams': [ // desired properties of the credential to be created, 
						// sequence ordered from most preferred to least preferred.
                { 'type': 'public-key', 'alg': -7  } //e.g. -7 for "ES256" and 
								,{ 'type': 'public-key', 'alg': -257 } // -257 for "RS256". 
            ],
		        //Since Edge shows UI, it is better to select larger timeout values
		        timeout: 50000
          }

				  document.getElementById("reg2").innerText = "navigator.credentials.create({publicKey:\n" + sf(publicKey) + "}";

          return navigator.credentials.create({ 'publicKey': publicKey })  // client adds client data hash?
          .then((rawAttestation) => {

	          log('RECEIVED AN ATTESTATION!');

						let clientData = parseClientDataJSON(rawAttestation.response.clientDataJSON);
          	log('ClientData: ', clientData);
						
          	let attestationObject = CBOR.decode(rawAttestation.response.attestationObject);
						/*
								attestationObject: {
									attStmt: Object, 
									authData: Array, 
									fmt: "packed" // "none", "packed", "tpm", "android-key","android-safetynet", "fido-u2f"
								}
						*/
	
						// Array attestationObject.authData: [RP ID hash | flags | counter | AAGUID | CredID | CredPubKey | Extensions]

		        let authData = parseAuthData(attestationObject.authData); // authData is an Array

	          log('AuthData: ', authData);
	          log('fmt: ', attestationObject.fmt);
	          log('AAGUID: ', bufToHex(authData.aaguid));
	          log('CredID: ', bufToHex(authData.credID));
	          log('UserPublicKey', CBOR.decode(authData.COSEPublicKey.buffer)); // credential public key is referred to as the user public key in FIDO UAF

						document.getElementById("reg3").innerText = 
								"rawAttestation:\n" + sf(publicKeyCredentialToJSON(rawAttestation)) + "\n" +
								"attestationObject:" + sf(attestationObject) + "\n" +
								"authData: " + attestationObject.authData.length + " bytes\n" + sf(authData) + "\n" 
								"UserPublicKey:" + sf(coseToJwk(authData.COSEPublicKey.buffer)) + "\n" +
								"clientData:\n" + sf(clientData);

						let ci = base64encode(authData.credID);
		        localStorage.setItem("credentialId", ci);
						showCredID(ci);

						alert('Received an Attestation of format: ' + attestationObject.fmt + ',\n saved credentialID:\n' + ci);
					})
          .catch((error) => {
              alert('fail to create credential! ' + error)
              log('fail to create credential!', error)
          })
  			})

        document.getElementById('login').addEventListener('submit', function(event) {
          event.preventDefault();

					var allowCredentials = [];
				  if (this.allowCredentialsSelection.checked) {
				      var credentialId = localStorage.getItem("credentialId");
							showCredID(credentialId);
				      if (!credentialId)
				          return Promise.reject("Please create a credential first");
				      
							allowCredentials = [{
          		  type: "public-key",
         			  id: Uint8Array.from(atob(credentialId), c=>c.charCodeAt(0)).buffer
        			}];
				  }

          var challenge = new Uint8Array(32);
          window.crypto.getRandomValues(challenge);

					var publicKey = { //  contains only the challenge 
						// authenticatorSelection.requireResidentKey is true, so there is no need to pass a credential

		        // specifies which credential IDs are allowed to authenticate the user
		        allowCredentials: allowCredentials,

		        //an opaque challenge that the authenticator signs over
		        challenge: challenge,

		        //Since Edge shows UI, it is better to select larger timeout values
		        timeout: 50000
					}

					document.getElementById("aut2").innerText = "navigator.credentials.get({publicKey:\n" + sf(publicKey)+ "}";

					return navigator.credentials.get({ 'publicKey': publicKey })
          .then((rawAssertion) => {

	          log('RECEIVED AN ASSERTION!');

						let clientData = parseClientDataJSON(rawAssertion.response.clientDataJSON);
          	log('ClientData: ', clientData);

						document.getElementById("aut3").innerText = "rawAssertion:\n" + 
							sf(publicKeyCredentialToJSON(rawAssertion)) + "\n" +
							sf(rawAssertion.response);

						// ArrayBuffer rawAssertion.response.authenticatorData: [RP ID hash | flags | counter | Attested CredData | Extensions]
						// [object AuthenticatorAssertionResponse]: {authenticatorData: ArrayBuffer, clientDataJSON: ArrayBuffer, signature: ArrayBuffer, userHandle: ArrayBuffer}

						let authDataBuffer = arrayBufferToArray(rawAssertion.response.authenticatorData)
						let authData = parseAuthData(authDataBuffer);

	          log('authData: ', authData);
	          log('userHandle:', base64encode(rawAssertion.response.userHandle));
	          log('signature: ', base64encode(rawAssertion.response.signature));

						document.getElementById("aut3").innerText = 
								"rawAssertion:\n" + sf(publicKeyCredentialToJSON(rawAssertion)) + "\n" +
								"authenticatorData: " + authDataBuffer.length + " bytes\n" + sf(authData) + "\n" +
								"userHandle:" + sf(base64encode(rawAssertion.response.userHandle))  + "\n" +
								"signature:" + sf(base64encode(rawAssertion.response.signature)) + "\n" +
								"clientData:\n" + sf(clientData);

	/*
		        var assertion = {
		            id: base64encode(rawAssertion.rawId),
		            clientData: parseClientDataJSON(rawAssertion.response.clientDataJSON),
		            userHandle: base64encode(rawAssertion.response.userHandle),
		            signature: base64encode(rawAssertion.response.signature),
		            authenticatorData: base64encode(rawAssertion.response.authenticatorData)
		        }
					  document.getElementById("aut4").innerText = "authenticatorData:\n" + sf(authData);
*/
						alert('Received an assertion with userHandle:\n' + base64encode(rawAssertion.response.userHandle))
          })
          .catch((error) => {
              alert('fail get credential! ' + error)
              log('fail to get credential', error)
          })
    		})


    </script>
    <script src="../lib/base64url-arraybuffer.js"></script>
    <script src="../lib/cbor.js"></script>
    <script src="../lib/helpers.js"></script>
</body>
</html>